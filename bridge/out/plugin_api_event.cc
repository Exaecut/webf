// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
// clang-format off
/*
 * Copyright (C) 2022-present The WebF authors. All rights reserved.
 */
#include "plugin_api/event.h"
#include "plugin_api/event_target.h"
#include "plugin_api/exception_state.h"
#include "plugin_api/executing_context.h"
#include "core/dom/events/event.h"
#include "core/dom/events/custom_event.h"
#include "core/native/script_value_ref.h"
#include "core/dom/events/event_target.h"
#include "core/events/animation_event.h"
#include "core/events/close_event.h"
#include "core/events/focus_event.h"
#include "core/events/gesture_event.h"
#include "core/events/hashchange_event.h"
#include "core/events/input_event.h"
#include "core/events/intersection_change_event.h"
#include "core/events/pop_state_event.h"
#include "core/events/mouse_event.h"
#include "core/api/exception_state.h"
#include "core/events/pointer_event.h"
#include "core/events/transition_event.h"
#include "core/events/ui_event.h"
#include "core/dom/legacy/element_attributes.h"
#include "core/css/inline_css_style_declaration.h"
#include "core/css/computed_css_style_declaration.h"
#include "core/dom/legacy/bounding_client_rect.h"
#include "core/dom/dom_string_map.h"
#include "core/timing/performance_mark.h"
#include "core/dom/mutation_observer_registration.h"
#include "core/input/touch_list.h"
#include "core/input/touch.h"
#include "core/timing/performance_measure.h"
#include "core/events/promise_rejection_event.h"
#include "core/events/hybrid_router_change_event.h"
#include "core/events/error_event.h"
#include "core/events/message_event.h"
#include "plugin_api/event_init.h"
namespace webf {
int32_t EventPublicMethods::Bubbles(Event* event) {
  return event->bubbles();
}
int32_t EventPublicMethods::CancelBubble(Event* event) {
  return event->cancelBubble();
}
void EventPublicMethods::SetCancelBubble(Event* event, int32_t cancelBubble, SharedExceptionState* shared_exception_state) {
  event->setCancelBubble(cancelBubble, shared_exception_state->exception_state);
}
int32_t EventPublicMethods::Cancelable(Event* event) {
  return event->cancelable();
}
WebFValue<EventTarget, EventTargetPublicMethods> EventPublicMethods::CurrentTarget(Event* event) {
  auto* result = event->currentTarget();
  WebFValueStatus* status_block = result->KeepAlive();
  return WebFValue<EventTarget, EventTargetPublicMethods>(result, result->eventTargetPublicMethods(), status_block);
}
int32_t EventPublicMethods::DefaultPrevented(Event* event) {
  return event->defaultPrevented();
}
WebFValue<EventTarget, EventTargetPublicMethods> EventPublicMethods::SrcElement(Event* event) {
  auto* result = event->srcElement();
  WebFValueStatus* status_block = result->KeepAlive();
  return WebFValue<EventTarget, EventTargetPublicMethods>(result, result->eventTargetPublicMethods(), status_block);
}
WebFValue<EventTarget, EventTargetPublicMethods> EventPublicMethods::Target(Event* event) {
  auto* result = event->target();
  WebFValueStatus* status_block = result->KeepAlive();
  return WebFValue<EventTarget, EventTargetPublicMethods>(result, result->eventTargetPublicMethods(), status_block);
}
int32_t EventPublicMethods::IsTrusted(Event* event) {
  return event->isTrusted();
}
double EventPublicMethods::TimeStamp(Event* event) {
  return event->timeStamp();
}
AtomicStringRef EventPublicMethods::Type(Event* event) {
  auto value_atomic = event->type();
  return AtomicStringRef(value_atomic);
}
void EventPublicMethods::InitEvent(Event* event, const char* type, int32_t bubbles, int32_t cancelable, SharedExceptionState* shared_exception_state) {
  webf::AtomicString type_atomic = webf::AtomicString(event->ctx(), type);
  event->initEvent(type_atomic, bubbles, cancelable, shared_exception_state->exception_state);
}
void EventPublicMethods::PreventDefault(Event* event, SharedExceptionState* shared_exception_state) {
  event->preventDefault(shared_exception_state->exception_state);
}
void EventPublicMethods::StopImmediatePropagation(Event* event, SharedExceptionState* shared_exception_state) {
  event->stopImmediatePropagation(shared_exception_state->exception_state);
}
void EventPublicMethods::StopPropagation(Event* event, SharedExceptionState* shared_exception_state) {
  event->stopPropagation(shared_exception_state->exception_state);
}
void EventPublicMethods::Release(Event* event) {
  event->ReleaseAlive();
}
WebFValue<Event, WebFPublicMethods> EventPublicMethods::DynamicTo(webf::Event* event, webf::EventType event_type) {
  switch (event_type) {
    case EventType::kEvent: {
      WebFValueStatus* status_block = event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(event, event->eventPublicMethods(), status_block);
    }
    case EventType::kCustomEvent: {
      auto* custom_event = webf::DynamicTo<CustomEvent>(event);
      if (custom_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = custom_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(custom_event, custom_event->customEventPublicMethods(), status_block);
    }
    case EventType::kGestureEvent: {
      auto* gesture_event = webf::DynamicTo<GestureEvent>(event);
      if (gesture_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = gesture_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(gesture_event, gesture_event->gestureEventPublicMethods(), status_block);
    }
    case EventType::kCloseEvent: {
      auto* close_event = webf::DynamicTo<CloseEvent>(event);
      if (close_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = close_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(close_event, close_event->closeEventPublicMethods(), status_block);
    }
    case EventType::kHybridRouterChangeEvent: {
      auto* hybrid_router_change_event = webf::DynamicTo<HybridRouterChangeEvent>(event);
      if (hybrid_router_change_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = hybrid_router_change_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(hybrid_router_change_event, hybrid_router_change_event->hybridRouterChangeEventPublicMethods(), status_block);
    }
    case EventType::kAnimationEvent: {
      auto* animation_event = webf::DynamicTo<AnimationEvent>(event);
      if (animation_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = animation_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(animation_event, animation_event->animationEventPublicMethods(), status_block);
    }
    case EventType::kMessageEvent: {
      auto* message_event = webf::DynamicTo<MessageEvent>(event);
      if (message_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = message_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(message_event, message_event->messageEventPublicMethods(), status_block);
    }
    case EventType::kErrorEvent: {
      auto* error_event = webf::DynamicTo<ErrorEvent>(event);
      if (error_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = error_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(error_event, error_event->errorEventPublicMethods(), status_block);
    }
    case EventType::kIntersectionChangeEvent: {
      auto* intersection_change_event = webf::DynamicTo<IntersectionChangeEvent>(event);
      if (intersection_change_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = intersection_change_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(intersection_change_event, intersection_change_event->intersectionChangeEventPublicMethods(), status_block);
    }
    case EventType::kUIEvent: {
      auto* ui_event = webf::DynamicTo<UIEvent>(event);
      if (ui_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = ui_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(ui_event, ui_event->uiEventPublicMethods(), status_block);
    }
    case EventType::kFocusEvent: {
      auto* focus_event = webf::DynamicTo<FocusEvent>(event);
      if (focus_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = focus_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(focus_event, focus_event->focusEventPublicMethods(), status_block);
    }
    case EventType::kInputEvent: {
      auto* input_event = webf::DynamicTo<InputEvent>(event);
      if (input_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = input_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(input_event, input_event->inputEventPublicMethods(), status_block);
    }
    case EventType::kMouseEvent: {
      auto* mouse_event = webf::DynamicTo<MouseEvent>(event);
      if (mouse_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = mouse_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(mouse_event, mouse_event->mouseEventPublicMethods(), status_block);
    }
    case EventType::kPointerEvent: {
      auto* pointer_event = webf::DynamicTo<PointerEvent>(event);
      if (pointer_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = pointer_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(pointer_event, pointer_event->pointerEventPublicMethods(), status_block);
    }
    case EventType::kPopStateEvent: {
      auto* pop_state_event = webf::DynamicTo<PopStateEvent>(event);
      if (pop_state_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = pop_state_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(pop_state_event, pop_state_event->popStateEventPublicMethods(), status_block);
    }
    case EventType::kTransitionEvent: {
      auto* transition_event = webf::DynamicTo<TransitionEvent>(event);
      if (transition_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = transition_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(transition_event, transition_event->transitionEventPublicMethods(), status_block);
    }
    case EventType::kPromiseRejectionEvent: {
      auto* promise_rejection_event = webf::DynamicTo<PromiseRejectionEvent>(event);
      if (promise_rejection_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = promise_rejection_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(promise_rejection_event, promise_rejection_event->promiseRejectionEventPublicMethods(), status_block);
    }
    case EventType::kHashchangeEvent: {
      auto* hashchange_event = webf::DynamicTo<HashchangeEvent>(event);
      if (hashchange_event == nullptr) {
        return WebFValue<Event, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = hashchange_event->KeepAlive();
      return WebFValue<Event, WebFPublicMethods>(hashchange_event, hashchange_event->hashchangeEventPublicMethods(), status_block);
    }
    default:
      assert_m(false, ("Unknown EventType " + std::to_string(static_cast<int32_t>(event_type))).c_str());
      return WebFValue<Event, WebFPublicMethods>::Null();
  }
}
WebFValue<Event, EventPublicMethods> ExecutingContextWebFMethods::CreateEvent(ExecutingContext* context, const char* type, ExceptionState& exception_state) {
  AtomicString type_atomic = AtomicString(context->ctx(), type);
  Event* event = Event::Create(context, type_atomic, exception_state);
  WebFValueStatus* status_block = event->KeepAlive();
  return WebFValue<Event, EventPublicMethods>(event, event->eventPublicMethods(), status_block);
};
WebFValue<Event, EventPublicMethods> ExecutingContextWebFMethods::CreateEventWithOptions(ExecutingContext* context, const char* type, WebFEventInit* init,  ExceptionState& exception_state) {
  AtomicString type_atomic = AtomicString(context->ctx(), type);
  std::shared_ptr<EventInit> init_class = EventInit::Create();
  init_class->setBubbles(init->bubbles);
  init_class->setCancelable(init->cancelable);
  init_class->setComposed(init->composed);
  Event* event = Event::Create(context, type_atomic, init_class, exception_state);
  WebFValueStatus* status_block = event->KeepAlive();
  return WebFValue<Event, EventPublicMethods>(event, event->eventPublicMethods(), status_block);
};
}  // namespace webf
