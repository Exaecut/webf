// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
// clang-format off
/*
 * Copyright (C) 2022-present The WebF authors. All rights reserved.
 */
#include "plugin_api/performance_entry.h"
#include "plugin_api/event_target.h"
#include "plugin_api/exception_state.h"
#include "plugin_api/executing_context.h"
#include "core/dom/events/event.h"
#include "core/dom/events/custom_event.h"
#include "core/native/script_value_ref.h"
#include "core/dom/events/event_target.h"
#include "core/events/animation_event.h"
#include "core/events/close_event.h"
#include "core/events/focus_event.h"
#include "core/events/gesture_event.h"
#include "core/events/hashchange_event.h"
#include "core/events/input_event.h"
#include "core/events/intersection_change_event.h"
#include "core/events/pop_state_event.h"
#include "core/events/mouse_event.h"
#include "core/api/exception_state.h"
#include "core/events/pointer_event.h"
#include "core/events/transition_event.h"
#include "core/events/ui_event.h"
#include "core/dom/legacy/element_attributes.h"
#include "core/css/inline_css_style_declaration.h"
#include "core/css/computed_css_style_declaration.h"
#include "core/dom/legacy/bounding_client_rect.h"
#include "core/dom/dom_string_map.h"
#include "core/timing/performance_mark.h"
#include "core/dom/mutation_observer_registration.h"
#include "core/input/touch_list.h"
#include "core/input/touch.h"
#include "core/timing/performance_measure.h"
#include "core/events/promise_rejection_event.h"
#include "core/events/hybrid_router_change_event.h"
#include "core/events/error_event.h"
#include "core/events/message_event.h"
namespace webf {
AtomicStringRef PerformanceEntryPublicMethods::Name(PerformanceEntry* performance_entry) {
  auto value_atomic = performance_entry->name();
  return AtomicStringRef(value_atomic);
}
AtomicStringRef PerformanceEntryPublicMethods::EntryType(PerformanceEntry* performance_entry) {
  auto value_atomic = performance_entry->entryType();
  return AtomicStringRef(value_atomic);
}
int64_t PerformanceEntryPublicMethods::StartTime(PerformanceEntry* performance_entry) {
  return performance_entry->startTime();
}
int64_t PerformanceEntryPublicMethods::Duration(PerformanceEntry* performance_entry) {
  return performance_entry->duration();
}
NativeValue PerformanceEntryPublicMethods::ToJSON(PerformanceEntry* performance_entry, SharedExceptionState* shared_exception_state) {
  auto return_value = performance_entry->toJSON(shared_exception_state->exception_state);
  auto return_native_value = return_value.ToNative(performance_entry->ctx(), shared_exception_state->exception_state, false);
  return return_native_value;
}
void PerformanceEntryPublicMethods::Release(PerformanceEntry* performance_entry) {
  performance_entry->ReleaseAlive();
}
WebFValue<PerformanceEntry, WebFPublicMethods> PerformanceEntryPublicMethods::DynamicTo(webf::PerformanceEntry* performance_entry, webf::PerformanceEntryType performance_entry_type) {
  switch (performance_entry_type) {
    case PerformanceEntryType::kPerformanceEntry: {
      WebFValueStatus* status_block = performance_entry->KeepAlive();
      return WebFValue<PerformanceEntry, WebFPublicMethods>(performance_entry, performance_entry->performanceEntryPublicMethods(), status_block);
    }
    case PerformanceEntryType::kPerformanceMeasure: {
      auto* performance_measure = webf::DynamicTo<PerformanceMeasure>(performance_entry);
      if (performance_measure == nullptr) {
        return WebFValue<PerformanceEntry, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = performance_measure->KeepAlive();
      return WebFValue<PerformanceEntry, WebFPublicMethods>(performance_measure, performance_measure->performanceMeasurePublicMethods(), status_block);
    }
    case PerformanceEntryType::kPerformanceMark: {
      auto* performance_mark = webf::DynamicTo<PerformanceMark>(performance_entry);
      if (performance_mark == nullptr) {
        return WebFValue<PerformanceEntry, WebFPublicMethods>::Null();
      }
      WebFValueStatus* status_block = performance_mark->KeepAlive();
      return WebFValue<PerformanceEntry, WebFPublicMethods>(performance_mark, performance_mark->performanceMarkPublicMethods(), status_block);
    }
    default:
      assert_m(false, ("Unknown PerformanceEntryType " + std::to_string(static_cast<int32_t>(performance_entry_type))).c_str());
      return WebFValue<PerformanceEntry, WebFPublicMethods>::Null();
  }
}
}  // namespace webf
